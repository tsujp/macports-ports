--- src/nsimage.m.orig
+++ src/nsimage.m
@@ -28,6 +28,7 @@ Updated by Christian Limpach (chris@nice.ch)
 /* This should be the first include, as it may set up #defines affecting
    interpretation of even the system includes.  */
 #include <config.h>
+#include <CoreGraphics/CoreGraphics.h>
 
 #include "lisp.h"
 #include "dispextern.h"
@@ -510,10 +511,20 @@ - (void) setAlphaAtX: (int) x Y: (int) y to: (unsigned char) a
 }
 
 /* Returns a pattern color, which is cached here.  */
-- (NSColor *)stippleMask
+- (CGImageRef)stippleMask
 {
-  if (stippleMask == nil)
-      stippleMask = [[NSColor colorWithPatternImage: self] retain];
+  if (stippleMask == nil) {
+    CGDataProviderRef provider = CGDataProviderCreateWithData (NULL, [bmRep bitmapData],
+                                                             [self sizeInBytes], NULL);
+    id mask = (id)CGImageMaskCreate(
+                                          [self size].width,
+                                          [self size].height,
+                                          8, 8, [self size].width,
+                                          provider, NULL, 0);
+
+    CGDataProviderRelease(provider);
+    stippleMask = (CGImageRef)[mask retain];
+  }
   return stippleMask;
 }
 
--- src/nsterm.h.orig
+++ src/nsterm.h
@@ -670,7 +670,7 @@ enum ns_return_frame_mode
 {
   NSBitmapImageRep *bmRep; /* used for accessing pixel data */
   unsigned char *pixmapData[5]; /* shortcut to access pixel data */
-  NSColor *stippleMask;
+  CGImageRef stippleMask;
 @public
   NSAffineTransform *transform;
   BOOL smoothing;
@@ -687,8 +687,8 @@ enum ns_return_frame_mode
                green: (unsigned char)g blue: (unsigned char)b
               alpha:(unsigned char)a;
 - (void)setAlphaAtX: (int)x Y: (int)y to: (unsigned char)a;
-- (NSColor *)stippleMask;
+- (CGImageRef)stippleMask;
 - (Lisp_Object)getMetadata;
 - (BOOL)setFrame: (unsigned int) index;
 - (void)setTransform: (double[3][3]) m;
 
--- src/nsterm.m.orig
+++ src/nsterm.m
@@ -2903,22 +2903,24 @@ Hide the window (X11 semantics)
 static void
 ns_define_fringe_bitmap (int which, unsigned short *bits, int h, int w)
 {
-  NSBezierPath *p = [NSBezierPath bezierPath];
-
   if (!fringe_bmp)
     fringe_bmp = [[NSMutableDictionary alloc] initWithCapacity:25];
 
-  [p moveToPoint:NSMakePoint (0, 0)];
 
-  for (int y = 0 ; y < h ; y++)
-    for (int x = 0 ; x < w ; x++)
-      {
-        bool bit = bits[y] & (1 << (w - x - 1));
-        if (bit)
-          [p appendBezierPathWithRect:NSMakeRect (x, y, 1, 1)];
-      }
+  for (int i = 0; i < h; i++)
+    bits[i] = ~bits[i];
+
+  CGDataProviderRef provider = CGDataProviderCreateWithData (NULL, bits,
+					   sizeof (unsigned short) * h, NULL);
+  if (provider) {
+    id p = (id)CGImageMaskCreate (w, h, 1, 1,
+                 sizeof (unsigned short),
+                 provider, NULL, 0);
+    CGDataProviderRelease (provider);
+
+    [fringe_bmp setObject:p forKey:[NSNumber numberWithInt:which]];
+  }
 
-  [fringe_bmp setObject:p forKey:[NSNumber numberWithInt:which]];
 }
 
 
@@ -2981,26 +2983,29 @@ Hide the window (X11 semantics)
       NSRectFill (clearRect);
     }
 
-  NSBezierPath *bmp = [fringe_bmp objectForKey:[NSNumber numberWithInt:p->which]];
+  CGImageRef bmp = (CGImageRef)[fringe_bmp objectForKey:[NSNumber numberWithInt:p->which]];
 
   if (bmp == nil
       && p->which < max_used_fringe_bitmap)
     {
       gui_define_fringe_bitmap (f, p->which);
-      bmp = [fringe_bmp objectForKey: [NSNumber numberWithInt: p->which]];
+      bmp = (CGImageRef)[fringe_bmp objectForKey: [NSNumber numberWithInt: p->which]];
     }
 
   if (bmp)
     {
-      NSAffineTransform *transform = [NSAffineTransform transform];
-      NSColor *bm_color;
+      CGRect bounds = CGRectMake (p->x, p->y - p->dh,
+			   CGImageGetWidth (bmp), CGImageGetHeight (bmp));
+
+      NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
+      [ctx saveGraphicsState];
+      CGContextRef context = [ctx CGContext];
 
-      /* Because the image is defined at (0, 0) we need to take a copy
-         and then transform that copy to the new origin.  */
-      bmp = [bmp copy];
-      [transform translateXBy:p->x yBy:p->y - p->dh];
-      [bmp transformUsingAffineTransform:transform];
+      CGContextTranslateCTM (context,
+			     CGRectGetMinX (bounds), CGRectGetMaxY (bounds));
+      CGContextScaleCTM (context, 1, -1);
 
+      NSColor *bm_color;
       if (!p->cursor_p)
         bm_color = [NSColor colorWithUnsignedLong:face->foreground];
       else if (p->overlay_p)
@@ -3009,9 +3014,10 @@ Hide the window (X11 semantics)
         bm_color = f->output_data.ns->cursor_color;
 
       [bm_color set];
-      [bmp fill];
+      bounds.origin = CGPointZero;
+      CGContextDrawImage (context, bounds, bmp);
 
-      [bmp release];
+      [[NSGraphicsContext currentContext] restoreGraphicsState];
     }
   ns_unfocus (f);
 }
@@ -3273,11 +3279,10 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
 ns_draw_underwave (struct glyph_string *s, EmacsCGFloat width, EmacsCGFloat x)
 {
   int wave_height = 3, wave_length = 2;
-  int y, dx, dy, odd, xmax;
-  NSPoint a, b;
+  int y, dx, dy, xmax;
   NSRect waveClip;
 
-  dx = wave_length;
+  dx = wave_length * 2;
   dy = wave_height - 1;
   y =  s->ybase - wave_height + 3;
   xmax = x + width;
@@ -3287,25 +3292,24 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
   [[NSGraphicsContext currentContext] saveGraphicsState];
   NSRectClip (waveClip);
 
-  /* Draw the waves */
-  a.x = x - ((int)(x) % dx) + (EmacsCGFloat) 0.5;
-  b.x = a.x + dx;
-  odd = (int)(a.x/dx) % 2;
-  a.y = b.y = y + 0.5;
+  float ax = x - ((int)(x) % dx);
+  float ay = y + wave_height / 2.0;
 
-  if (odd)
-    a.y += dy;
-  else
-    b.y += dy;
+  NSBezierPath *path = [[NSBezierPath alloc] init];
+  [path moveToPoint: (NSPoint){ ax, ay }];
+
+  NSPoint stepOne = { dx, 0 };
+  NSPoint controlOne = { 0.5 * dx, dy };
+  NSPoint controlTwo = { 0.5 * dx, -dy };
 
-  while (a.x <= xmax)
+  while (ax <= xmax)
     {
-      [NSBezierPath strokeLineFromPoint:a toPoint:b];
-      a.x = b.x, a.y = b.y;
-      b.x += dx, b.y = y + 0.5 + odd*dy;
-      odd = !odd;
+      [path relativeCurveToPoint:stepOne controlPoint1:controlOne controlPoint2:controlTwo];
+      ax += dx;
     }
 
+  [path stroke];
+
   /* Restore previous clipping rectangle(s) */
   [[NSGraphicsContext currentContext] restoreGraphicsState];
 }
@@ -3825,10 +3829,35 @@ Function modeled after x_draw_glyph_string_box ().
       int box_line_width = max (s->face->box_horizontal_line_width, 0);
 
       if (s->stippled_p)
-	{
-	  struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (s->f);
-	  [[dpyinfo->bitmaps[face->stipple-1].img stippleMask] set];
-	  goto fill;
+        {
+          [[NSColor colorWithUnsignedLong:face->background] set];
+          r = NSMakeRect (s->x, s->y + box_line_width,
+                          s->background_width,
+                          s->height - 2 * box_line_width);
+          NSRectFill (r);
+          s->background_filled_p = 1;
+
+          struct ns_display_info *dpyinfo = FRAME_DISPLAY_INFO (s->f);
+          CGImageRef mask =
+            [dpyinfo->bitmaps[face->stipple - 1].img stippleMask];
+
+          CGRect bounds = CGRectMake (s->x, s->y + box_line_width,
+                                      s->background_width,
+                                      s->height - 2 * box_line_width);
+          NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
+          [ctx saveGraphicsState];
+          CGContextRef context = [ctx CGContext];
+
+          CGContextClipToRect (context, bounds);
+
+          CGContextScaleCTM (context, 1, -1);
+          [[NSColor colorWithUnsignedLong:face->foreground] set];
+
+          CGRect imageSize = CGRectMake (0, 0, CGImageGetWidth (mask),
+                                         CGImageGetHeight (mask));
+
+          CGContextDrawTiledImage (context, imageSize, mask);
+          [[NSGraphicsContext currentContext] restoreGraphicsState];
 	}
       else if (FONT_HEIGHT (s->font) < s->height - 2 * box_line_width
 	       /* When xdisp.c ignores FONT_HEIGHT, we cannot trust font
@@ -3851,7 +3880,6 @@ Function modeled after x_draw_glyph_string_box ().
 	  else
 	    [FRAME_CURSOR_COLOR (s->f) set];
 
-	fill:
 	  r = NSMakeRect (s->x, s->y + box_line_width,
 			  s->background_width,
 			  s->height - 2 * box_line_width);
@@ -4175,12 +4203,42 @@ Function modeled after x_draw_glyph_string_box ().
 	  dpyinfo = FRAME_DISPLAY_INFO (s->f);
 	  if (s->hl == DRAW_CURSOR)
 	    [FRAME_CURSOR_COLOR (s->f) set];
-	  else if (s->stippled_p)
-	    [[dpyinfo->bitmaps[s->face->stipple - 1].img stippleMask] set];
-	  else
+	  else if (s->stippled_p) {
+              [[NSColor colorWithUnsignedLong:s->face->background]
+                set];
+              NSRectFill (
+                NSMakeRect (x, s->y, background_width, s->height));
+
+              CGImageRef mask =
+                [dpyinfo->bitmaps[s->face->stipple - 1]
+                    .img stippleMask];
+
+              CGRect bounds
+                = CGRectMake (s->x, s->y, s->background_width,
+                              s->height);
+
+              NSGraphicsContext *ctx =
+                [NSGraphicsContext currentContext];
+              [ctx saveGraphicsState];
+              CGContextRef context = [ctx CGContext];
+              CGContextClipToRect(context, bounds);
+              CGContextScaleCTM (context, 1, -1);
+              [[NSColor colorWithUnsignedLong:s->face->foreground]
+                set];
+
+              CGRect imageSize
+                = CGRectMake (0, 0, CGImageGetWidth (mask),
+                              CGImageGetHeight (mask));
+
+              CGContextDrawTiledImage (context, imageSize, mask);
+
+              [[NSGraphicsContext currentContext]
+		restoreGraphicsState];
+	    }
+	  else {
 	    [[NSColor colorWithUnsignedLong: s->face->background] set];
-
-	  NSRectFill (NSMakeRect (x, s->y, background_width, s->height));
+            NSRectFill (NSMakeRect (x, s->y, background_width, s->height));
+          }
 	}
     }
 
